#import <Cocoa/Cocoa.h>
#import <OpenGL/gl.h>
#import <glop.h>
#import <mach/mach_time.h>
#import <stdio.h>

NSAutoreleasePool* pool;
NSApplication* glop_app;

KeyEvent* glop_key_events;
int glop_key_events_cap;
int glop_key_events_len;

// This is a map of keycodes generated by OSX to Glop keycodes
// This does not contain any modifier keys, those are handled separately
const int key_map[] = {
  'a', 's', 'd', 'f', 'h',
  'g', 'z', 'x', 'c', 'v',
    0, 'b', 'q', 'w', 'e',
  'r', 'y', 't', '1', '2',
  '3', '4', '6', '5', '!',
  '9', '7', '-', '8', '0',
  ']', 'o', 'u', '[', 'i',
  'p', kKeyEnter, 'l', 'j', '\'',
  'k', ';', '\\', ',', '/',
  'n', 'm', '.', kKeyTab, ' ',
  '`', kKeyBackspace, 0, kKeyEscape, 0,             // 50
  0, 0, 0, 0, 0,
//  kKeyGUI, 0, 0, 0, 0,   <- TODO: Where is this supposed to be defined?
  0, 0, 0, 0, 0,
  kKeyPadDecimal, 0, kKeyPadMultiply, 0, kKeyPadAdd,
  0, 0, 0, 0, 0,
//  0, kKeyPadClear, 0, 0, 0,  <- TODO: Where is this supposed to be defined?
  kKeyPadDivide, 0, kKeyPadEnter, kKeyPadSubtract, 0,
  0, 0, kKeyPad0, kKeyPad1, kKeyPad2,
  kKeyPad3, kKeyPad4, kKeyPad5, kKeyPad6, kKeyPad7,
  kKeyPad8, kKeyPad9, 0, 0, 0,
  0, kKeyF5, kKeyF6, kKeyF7, kKeyF3,
  kKeyF8, kKeyF9, 0, kKeyF11, 0,                    // 100
  kKeyPrintScreen, 0, 0, 0, kKeyF10,
  0, kKeyF12, 0, 0, 0,
//  0, kKeyF12, 0, 0, kKeyHelp,  <- TODO: Where is this supposed to be defined?
  kKeyHome, kKeyPageUp, kKeyDelete, kKeyF4, kKeyEnd,
  kKeyF2, kKeyPageDown, kKeyF1, kKeyLeft, kKeyRight,
  kKeyDown, kKeyUp,
  -1, -1, -1, -1, -1
};

struct inputState {
  int mouse_x;
  int mouse_y;

// modifiers
  int num_lock;
  int caps_lock;
  int left_shift;
  int right_shift;
  int left_alt;
  int right_alt;
  int left_ctrl;
  int right_ctrl;
  int left_gui;
  int right_gui;
  int function;
} inputState;

// Modifier flags
const int kOsxCapsLock =     10000;
const int kOsxFunction =     800000;
const int kOsxLeftControl =  40001;
// TODO: Use a keyboard with a Right Control button so we can make sure we get this value right!!
//       Num lock too!!!
const int kOsxRightControl = 40000;
const int kOsxLeftShift =    20002;
const int kOsxRightShift =   20004;
const int kOsxLeftAlt =      80020;
const int kOsxRightAlt =     80040;
const int kOsxLeftGui =      100008;
const int kOsxRightGui =     100010;

int* getInputStateVal(int flag) {
  if (flag == kOsxCapsLock)     return &inputState.caps_lock;
  if (flag == kOsxFunction)     return &inputState.function;
  if (flag == kOsxLeftShift)    return &inputState.left_shift;
  if (flag == kOsxRightShift)   return &inputState.right_shift;
  if (flag == kOsxLeftAlt)      return &inputState.left_alt;
  if (flag == kOsxRightAlt)     return &inputState.right_alt;
  if (flag == kOsxLeftControl)  return &inputState.left_ctrl;
  if (flag == kOsxRightControl) return &inputState.right_ctrl;
  if (flag == kOsxLeftGui)      return &inputState.left_gui;
  if (flag == kOsxRightGui)     return &inputState.right_gui;
  return 0;
}


@interface GlopApplication : NSApplication {
}
- (void)sendEvent:(NSEvent*)event;
@end

KeyEvent* newEvent() {
  KeyEvent* key_event = &glop_key_events[glop_key_events_len];
  glop_key_events_len++;
  key_event->device = glopDeviceKeyboard;
  key_event->mouse_dx = 0;
  key_event->mouse_dy = 0;
  key_event->press_amt = 0;
  key_event->cursor_x = inputState.mouse_x;
  key_event->cursor_y = inputState.mouse_y;
  key_event->num_lock = 0;
  key_event->caps_lock = 0;
  return key_event;
}

@implementation GlopApplication
- (void)sendEvent:(NSEvent*)event {
printf("sendEvent IN\n");
/*
   NSLeftMouseDown      = 1,
   NSLeftMouseUp        = 2,
   NSRightMouseDown     = 3,
   NSRightMouseUp       = 4,
   NSMouseMoved         = 5,
   NSKeyDown            = 10,
   NSKeyUp              = 11,
   NSFlagsChanged       = 12,
   NSApplicationDefined = 15,
   NSPeriodic           = 16,
   NSCursorUpdate       = 17,
   NSScrollWheel        = 22,
   NSOtherMouseDown     = 25,
   NSOtherMouseUp       = 26,
*/
  if ([event type] == NSApplicationDefined) {
    KeyEvent* key_event = newEvent();
    [glop_app stop:self];
printf("TERM\n");
    return;
  }
  if ([event type] == NSFlagsChanged) {
    NSUInteger flags =  [event modifierFlags];
printf("Modifiers: %x\n", flags);
    int flag[8];
    flag[0] = kOsxCapsLock;
    flag[1] = kOsxLeftControl;
    flag[2] = kOsxLeftShift;
    flag[3] = kOsxRightShift;
    flag[4] = kOsxLeftAlt;
    flag[5] = kOsxRightAlt;
    flag[6] = kOsxLeftGui;
    flag[7] = kOsxRightGui;
    int glopKeyCode[8];
    glopKeyCode[0] = kKeyCapsLock;
    glopKeyCode[1] = kKeyLeftControl;
    glopKeyCode[2] = kKeyLeftShift;
    glopKeyCode[3] = kKeyRightShift;
    glopKeyCode[4] = kKeyLeftAlt;
    glopKeyCode[5] = kKeyRightAlt;
    glopKeyCode[6] = kKeyLeftGui;
    glopKeyCode[7] = kKeyRightGui;
    int i;
    for (i = 0; i < 8; i++) {
      int* val = getInputStateVal(flag[i]);
      if ((*val != 0) != ((flag[i] & flags) == flag[i])) {
        KeyEvent* key_event = newEvent();
        if (*val == 0) {
          key_event->index = glopKeyCode[i];
        }
      }
    }
  } else if ([event type] == NSMouseMoved) {
    NSPoint window_cursor = [event locationInWindow];
    NSWindow* window = [event window];
    NSPoint cursor = window_cursor;
    if (window != nil) {
      cursor = [window convertBaseToScreen:window_cursor];
    }
    KeyEvent* key_event = newEvent();
    key_event->mouse_dx = (int)(cursor.x - inputState.mouse_x);
    key_event->mouse_dy = (int)(cursor.y - inputState.mouse_y);
    inputState.mouse_x = (int)(cursor.x);
    inputState.mouse_y = (int)(cursor.y);
    key_event->cursor_x = inputState.mouse_x;
    key_event->cursor_y = inputState.mouse_y;
  } else if ([event type] == NSKeyDown ||
             [event type] == NSKeyUp) {
    KeyEvent* key_event = newEvent();
    key_event->index = key_map[[event keyCode]];
    key_event->press_amt = 0;
    if ([event type] == NSKeyDown) {
      key_event->press_amt = 1;
    }
  } else if ([event type] == NSLeftMouseDown  ||
             [event type] == NSLeftMouseUp    ||
             [event type] == NSRightMouseDown ||
             [event type] == NSRightMouseUp) {
    KeyEvent* key_event = newEvent();
    key_event->index = -1;
    if ([event type] == NSLeftMouseDown || [event type] == NSLeftMouseUp) {
      key_event->index = kMouseLButton;
    }
    if ([event type] == NSRightMouseDown || [event type] == NSRightMouseUp) {
      key_event->index = kMouseRButton;
    }
    key_event->press_amt = 0;
    if ([event type] == NSLeftMouseDown || [event type] == NSRightMouseDown) {
      key_event->press_amt = 1;
    }
  } else {
    [super sendEvent: event];
  }
printf("Returning normally\n");
}
@end

void Init() {
  glop_app = [GlopApplication sharedApplication];
  pool = [[NSAutoreleasePool alloc] init];
  glop_key_events_len = 0;
  glop_key_events_cap = 1000;  // TODO: Should we actually double if we get more than 1000 events?
  glop_key_events = (KeyEvent*)malloc(sizeof(KeyEvent) * glop_key_events_len);
}

void Think() {
  uint64_t uptime = mach_absolute_time();
printf("Think1\n");
  NSEvent* event = [NSEvent otherEventWithType:NSApplicationDefined location:NSZeroPoint modifierFlags:0 timestamp:(NSTimeInterval)uptime windowNumber:0 context:0 subtype:0 data1:0 data2:0];
printf("Think2\n");
  [glop_app postEvent:event atStart:NO];
printf("Think3 %x\n", glop_app);
  [glop_app run];
printf("Think4\n");
}

void GetInputEvents(void** _key_events, int* length) {
  *_key_events = glop_key_events;
  *length = glop_key_events_len;
  glop_key_events_len = 0;
}

void CreateWindow(void** _window, void** _context, int x, int y, int width, int height) {
  NSRect windowRect = NSMakeRect(x, y, width, height);
  NSWindow* window = [NSWindow alloc];
  *((NSWindow**)(_window)) = window;
  [window initWithContentRect:windowRect 
  styleMask:( NSResizableWindowMask | NSClosableWindowMask | NSTitledWindowMask) 
  backing:NSBackingStoreBuffered defer:NO];
  [window makeKeyAndOrderFront:nil];
  [window setAcceptsMouseMovedEvents:YES];
  NSPoint window_cursor = [window mouseLocationOutsideOfEventStream];
  NSPoint cursor = [window convertBaseToScreen:window_cursor];
  inputState.mouse_x = cursor.x;
  inputState.mouse_y = cursor.y;

  // Create and bind an OpenGL context
  NSOpenGLPixelFormatAttribute attributes[] = {
    NSOpenGLPFADoubleBuffer,
    NSOpenGLPFAAccelerated,
    NSOpenGLPFAColorSize, 32,
    NSOpenGLPFADepthSize, 32,
    //    NSOpenGLPFAFullScreen,
    0,
  };
  NSOpenGLPixelFormat* pixel_format = [[NSOpenGLPixelFormat alloc] initWithAttributes:attributes];
  if (pixel_format == nil) {
    // TODO: How do we signal this properly?
    exit(0);
    return;
  }
  NSOpenGLContext* context = [NSOpenGLContext alloc];
  *((NSOpenGLContext**)(_context)) = context;
  [context initWithFormat:pixel_format shareContext:NO];
  [context setView:[window contentView]];
  [context makeCurrentContext];
  glClear(GL_COLOR_BUFFER_BIT);
  [context flushBuffer];
}

void SwapBuffers(void* _context) {
  NSOpenGLContext* context = (NSOpenGLContext*)(_context);
  [context flushBuffer];
}

void ShutDown() {
  [pool drain];
}

void Run() {
  [NSApp run];
}

void CurrentMousePos(void* _window, void* _x, void* _y) {
  NSWindow* window = (NSWindow*)_window;
  int* x = (int*)_x;
  int* y = (int*)_y;
  NSPoint point = [window mouseLocationOutsideOfEventStream];
  *x = (int)point.x;
  *y = (int)point.y;
}
