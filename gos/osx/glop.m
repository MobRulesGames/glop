#import <Cocoa/Cocoa.h>
#import <OpenGL/gl.h>
#import <glop.h>
#import <mach/mach_time.h>
#import <stdio.h>

@interface GlopApplication : NSApplication {
}
- (void)sendEvent:(NSEvent*)event;
@end

struct inputState {
  int mouse_x;
  int mouse_y;

// modifiers
  int num_lock;
  int caps_lock;
  int left_shift;
  int right_shift;
  int left_alt;
  int right_alt;
  int left_ctrl;
  int right_ctrl;
  int left_gui;
  int right_gui;
  int function;
} inputState;

void ClearEvent(KeyEvent* event) {
  event->device = glopDeviceKeyboard;
  event->mouse_dx = 0;
  event->mouse_dy = 0;
  event->press_amt = 0;
  event->cursor_x = inputState.mouse_x;
  event->cursor_y = inputState.mouse_y;
  event->num_lock = 0;
  event->caps_lock = 0;
}

NSAutoreleasePool* pool;
NSApplication* glop_app;
NSEvent* terminator;

// These structures provide a way to allow threads to write events to a buffer
// and then grab the events as a batch in a synchronously.
typedef struct {
  KeyEvent events[1000];
  int length;
} EventGroup;

EventGroup event_buffer_1;
EventGroup event_buffer_2;
EventGroup *current_event_buffer;
pthread_mutex_t event_group_mutex;

// Safely adds the event to current event buffer and increments its length
void AddEvent(KeyEvent* event) {
  pthread_mutex_lock(&event_group_mutex);

  current_event_buffer->events[current_event_buffer->length] = *event;
  current_event_buffer->length++;

  pthread_mutex_unlock(&event_group_mutex);
}

// Returns a pointer to all of the current events as well as the number of events in the buffer
// Swaps the current buffer so that new events go into the other buffer, the events returned
// by this function should be used before the next time this function is called.
void GetEvents(KeyEvent** events, int* length) {
  pthread_mutex_lock(&event_group_mutex);

  *events = current_event_buffer->events;
  *length = current_event_buffer->length;

  if (current_event_buffer == &event_buffer_1) {
    current_event_buffer = &event_buffer_2;
  } else {
    current_event_buffer = &event_buffer_1;
  }
  current_event_buffer->length = 0;

  pthread_mutex_unlock(&event_group_mutex);
}

void Init() {
  glop_app = [GlopApplication sharedApplication];
  pool = [[NSAutoreleasePool alloc] init];

  terminator = [NSEvent
      otherEventWithType:NSApplicationDefined
      location:NSZeroPoint
      modifierFlags:0
      timestamp:(NSTimeInterval)0
      windowNumber:0
      context:0
      subtype:0
      data1:0
      data2:0];

  // EventGroup init stuff
  current_event_buffer = &event_buffer_1;
  event_buffer_1.length = 0;
  event_buffer_2.length = 0;
  pthread_mutex_init(&event_group_mutex, NULL);
}


// This is a map of keycodes generated by OSX to Glop keycodes
// This does not contain any modifier keys, those are handled separately
const int key_map[] = {
  'a', 's', 'd', 'f', 'h',
  'g', 'z', 'x', 'c', 'v',
    0, 'b', 'q', 'w', 'e',
  'r', 'y', 't', '1', '2',
  '3', '4', '6', '5', '!',
  '9', '7', '-', '8', '0',
  ']', 'o', 'u', '[', 'i',
  'p', kKeyEnter, 'l', 'j', '\'',
  'k', ';', '\\', ',', '/',
  'n', 'm', '.', kKeyTab, ' ',
  '`', kKeyBackspace, 0, kKeyEscape, 0,             // 50
  0, 0, 0, 0, 0,
//  kKeyGUI, 0, 0, 0, 0,   <- TODO: Where is this supposed to be defined?
  0, 0, 0, 0, 0,
  kKeyPadDecimal, 0, kKeyPadMultiply, 0, kKeyPadAdd,
  0, 0, 0, 0, 0,
//  0, kKeyPadClear, 0, 0, 0,  <- TODO: Where is this supposed to be defined?
  kKeyPadDivide, 0, kKeyPadEnter, kKeyPadSubtract, 0,
  0, 0, kKeyPad0, kKeyPad1, kKeyPad2,
  kKeyPad3, kKeyPad4, kKeyPad5, kKeyPad6, kKeyPad7,
  kKeyPad8, kKeyPad9, 0, 0, 0,
  0, kKeyF5, kKeyF6, kKeyF7, kKeyF3,
  kKeyF8, kKeyF9, 0, kKeyF11, 0,                    // 100
  kKeyPrintScreen, 0, 0, 0, kKeyF10,
  0, kKeyF12, 0, 0, 0,
//  0, kKeyF12, 0, 0, kKeyHelp,  <- TODO: Where is this supposed to be defined?
  kKeyHome, kKeyPageUp, kKeyDelete, kKeyF4, kKeyEnd,
  kKeyF2, kKeyPageDown, kKeyF1, kKeyLeft, kKeyRight,
  kKeyDown, kKeyUp,
  -1, -1, -1, -1, -1
};

// Modifier flags
const int kOsxCapsLock =     10000;
const int kOsxFunction =     800000;
const int kOsxLeftControl =  40001;
// TODO: Use a keyboard with a Right Control button so we can make sure we get this value right!!
//       Num lock too!!!
const int kOsxRightControl = 40000;
const int kOsxLeftShift =    20002;
const int kOsxRightShift =   20004;
const int kOsxLeftAlt =      80020;
const int kOsxRightAlt =     80040;
const int kOsxLeftGui =      100008;
const int kOsxRightGui =     100010;

int* getInputStateVal(int flag) {
  if (flag == kOsxCapsLock)     return &inputState.caps_lock;
  if (flag == kOsxFunction)     return &inputState.function;
  if (flag == kOsxLeftShift)    return &inputState.left_shift;
  if (flag == kOsxRightShift)   return &inputState.right_shift;
  if (flag == kOsxLeftAlt)      return &inputState.left_alt;
  if (flag == kOsxRightAlt)     return &inputState.right_alt;
  if (flag == kOsxLeftControl)  return &inputState.left_ctrl;
  if (flag == kOsxRightControl) return &inputState.right_ctrl;
  if (flag == kOsxLeftGui)      return &inputState.left_gui;
  if (flag == kOsxRightGui)     return &inputState.right_gui;
  return 0;
}

@implementation GlopApplication
- (void)sendEvent:(NSEvent*)event {
/*
   NSLeftMouseDown      = 1,
   NSLeftMouseUp        = 2,
   NSRightMouseDown     = 3,
   NSRightMouseUp       = 4,
   NSMouseMoved         = 5,
   NSKeyDown            = 10,
   NSKeyUp              = 11,
   NSFlagsChanged       = 12,
   NSApplicationDefined = 15,
   NSPeriodic           = 16,
   NSCursorUpdate       = 17,
   NSScrollWheel        = 22,
   NSOtherMouseDown     = 25,
   NSOtherMouseUp       = 26,
*/
// TODO: We need this here if we want to be able to break out of the Run loop
  if ([event type] == NSApplicationDefined) {
    [glop_app stop:self];
    return;
  }
  if ([event type] == NSFlagsChanged) {
    NSUInteger flags =  [event modifierFlags];
    int flag[8];
    flag[0] = kOsxCapsLock;
    flag[1] = kOsxLeftControl;
    flag[2] = kOsxLeftShift;
    flag[3] = kOsxRightShift;
    flag[4] = kOsxLeftAlt;
    flag[5] = kOsxRightAlt;
    flag[6] = kOsxLeftGui;
    flag[7] = kOsxRightGui;
    int glopKeyCode[8];
    glopKeyCode[0] = kKeyCapsLock;
    glopKeyCode[1] = kKeyLeftControl;
    glopKeyCode[2] = kKeyLeftShift;
    glopKeyCode[3] = kKeyRightShift;
    glopKeyCode[4] = kKeyLeftAlt;
    glopKeyCode[5] = kKeyRightAlt;
    glopKeyCode[6] = kKeyLeftGui;
    glopKeyCode[7] = kKeyRightGui;
    int i;
    for (i = 0; i < 8; i++) {
      int* val = getInputStateVal(flag[i]);
      if ((*val != 0) != ((flag[i] & flags) == flag[i])) {
        KeyEvent key_event;
        ClearEvent(&key_event);
        if (*val == 0) {
          key_event.index = glopKeyCode[i];
        }
      }
    }
  } else if ([event type] == NSMouseMoved) {
    NSPoint window_cursor = [event locationInWindow];
    NSWindow* window = [event window];
    NSPoint cursor = window_cursor;
    if (window != nil) {
      cursor = [window convertBaseToScreen:window_cursor];
    }
    KeyEvent key_event;
    ClearEvent(&key_event);
    key_event.index = kNoKey;
    key_event.mouse_dx = (int)(cursor.x - inputState.mouse_x);
    key_event.mouse_dy = (int)(cursor.y - inputState.mouse_y);
    inputState.mouse_x = (int)(cursor.x);
    inputState.mouse_y = (int)(cursor.y);
    key_event.cursor_x = inputState.mouse_x;
    key_event.cursor_y = inputState.mouse_y;
    AddEvent(&key_event);
  } else if ([event type] == NSKeyDown ||
             [event type] == NSKeyUp) {
    KeyEvent key_event;
    ClearEvent(&key_event);
    key_event.index = key_map[[event keyCode]];
    key_event.press_amt = 0;
    if ([event type] == NSKeyDown) {
      key_event.press_amt = 1;
    }
    AddEvent(&key_event);
  } else if ([event type] == NSLeftMouseDown  ||
             [event type] == NSLeftMouseUp    ||
             [event type] == NSRightMouseDown ||
             [event type] == NSRightMouseUp) {
    KeyEvent key_event;
    ClearEvent(&key_event);
    key_event.index = -1;
    if ([event type] == NSLeftMouseDown || [event type] == NSLeftMouseUp) {
      key_event.index = kMouseLButton;
    }
    if ([event type] == NSRightMouseDown || [event type] == NSRightMouseUp) {
      key_event.index = kMouseRButton;
    }
    key_event.press_amt = 0;
    if ([event type] == NSLeftMouseDown || [event type] == NSRightMouseDown) {
      key_event.press_amt = 1;
    }
    AddEvent(&key_event);
  } else {
    [super sendEvent: event];
  }
}
@end

void Quit() {
  [glop_app postEvent:terminator atStart:FALSE];
}

void Think() {
  uint64_t uptime = mach_absolute_time();
  NSEvent* event = [NSEvent otherEventWithType:NSApplicationDefined location:NSZeroPoint modifierFlags:0 timestamp:(NSTimeInterval)uptime windowNumber:0 context:0 subtype:0 data1:0 data2:0];
  [glop_app postEvent:event atStart:FALSE];
  [glop_app run];
}

void GetInputEvents(void** _key_events, int* length) {
  GetEvents((KeyEvent**)_key_events, length);
}

void CreateWindow(void** _window, void** _context, int x, int y, int width, int height) {
  NSRect windowRect = NSMakeRect(x, y, width, height);
  NSWindow* window = [NSWindow alloc];
  *((NSWindow**)(_window)) = window;
  [window initWithContentRect:windowRect 
  styleMask:( NSResizableWindowMask | NSClosableWindowMask | NSTitledWindowMask) 
  backing:NSBackingStoreBuffered defer:NO];
  [window makeKeyAndOrderFront:nil];
  [window setAcceptsMouseMovedEvents:YES];
  NSPoint window_cursor = [window mouseLocationOutsideOfEventStream];
  NSPoint cursor = [window convertBaseToScreen:window_cursor];
  inputState.mouse_x = cursor.x;
  inputState.mouse_y = cursor.y;

  // Create and bind an OpenGL context
  NSOpenGLPixelFormatAttribute attributes[] = {
    NSOpenGLPFADoubleBuffer,
    NSOpenGLPFAAccelerated,
    NSOpenGLPFAColorSize, 32,
    NSOpenGLPFADepthSize, 32,
    //    NSOpenGLPFAFullScreen,
    0,
  };
  NSOpenGLPixelFormat* pixel_format = [[NSOpenGLPixelFormat alloc] initWithAttributes:attributes];
  if (pixel_format == nil) {
    // TODO: How do we signal this properly?
    exit(0);
    return;
  }
  NSOpenGLContext* context = [NSOpenGLContext alloc];
  *((NSOpenGLContext**)(_context)) = context;
  [context initWithFormat:pixel_format shareContext:NO];
  [context setView:[window contentView]];
  [context makeCurrentContext];
  glClear(GL_COLOR_BUFFER_BIT);
  [context flushBuffer];
}

void SwapBuffers(void* _context) {
  NSOpenGLContext* context = (NSOpenGLContext*)(_context);
  [context flushBuffer];
}

void ShutDown() {
  [pool drain];
}

void Run() {
  [NSApp run];
}

void CurrentMousePos(void* _window, void* _x, void* _y) {
  NSWindow* window = (NSWindow*)_window;
  int* x = (int*)_x;
  int* y = (int*)_y;
  NSPoint point = [window mouseLocationOutsideOfEventStream];
  *x = (int)point.x;
  *y = (int)point.y;
}
